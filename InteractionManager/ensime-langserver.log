[2019-11-29 11:49:27,674] INFO org.github.dragos.vscode.Main$ - Starting server in /home/carlo/Documents/IoT/GPSChat/InteractionManager
[2019-11-29 11:49:27,674] INFO org.github.dragos.vscode.Main$ - Starting server in /home/carlo/Documents/IoT/GPSChat/InteractionManager
[2019-11-29 11:49:27,686] INFO org.github.dragos.vscode.Main$ - Classpath: /home/carlo/.vscode/extensions/dragos.scala-lsp-0.2.3/coursier
[2019-11-29 11:49:27,686] INFO org.github.dragos.vscode.Main$ - Classpath: /home/carlo/.vscode/extensions/dragos.scala-lsp-0.2.3/coursier
[2019-11-29 11:49:27,854] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 1233
[2019-11-29 11:49:27,854] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 1233
[2019-11-29 11:49:27,885] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":24616,"rootPath":"/home/carlo/Documents/IoT/GPSChat/InteractionManager","rootUri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager","capabilities":{"workspace":{"applyEdit":true,"didChangeConfiguration":{"dynamicRegistration":false},"didChangeWatchedFiles":{"dynamicRegistration":false},"symbol":{"dynamicRegistration":true},"executeCommand":{"dynamicRegistration":true}},"textDocument":{"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"completionItem":{"snippetSupport":true}},"hover":{"dynamicRegistration":true},"signatureHelp":{"dynamicRegistration":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"definition":{"dynamicRegistration":true},"codeAction":{"dynamicRegistration":true},"codeLens":{"dynamicRegistration":true},"documentLink":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true}}},"trace":"off"}}
[2019-11-29 11:49:27,885] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":0,"method":"initialize","params":{"processId":24616,"rootPath":"/home/carlo/Documents/IoT/GPSChat/InteractionManager","rootUri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager","capabilities":{"workspace":{"applyEdit":true,"didChangeConfiguration":{"dynamicRegistration":false},"didChangeWatchedFiles":{"dynamicRegistration":false},"symbol":{"dynamicRegistration":true},"executeCommand":{"dynamicRegistration":true}},"textDocument":{"synchronization":{"dynamicRegistration":true,"willSave":true,"willSaveWaitUntil":true,"didSave":true},"completion":{"dynamicRegistration":true,"completionItem":{"snippetSupport":true}},"hover":{"dynamicRegistration":true},"signatureHelp":{"dynamicRegistration":true},"references":{"dynamicRegistration":true},"documentHighlight":{"dynamicRegistration":true},"documentSymbol":{"dynamicRegistration":true},"formatting":{"dynamicRegistration":true},"rangeFormatting":{"dynamicRegistration":true},"onTypeFormatting":{"dynamicRegistration":true},"definition":{"dynamicRegistration":true},"codeAction":{"dynamicRegistration":true},"codeLens":{"dynamicRegistration":true},"documentLink":{"dynamicRegistration":true},"rename":{"dynamicRegistration":true}}},"trace":"off"}}
[2019-11-29 11:49:28,367] INFO org.github.dragos.vscode.EnsimeLanguageServer - Initialized with 24616, /home/carlo/Documents/IoT/GPSChat/InteractionManager, ClientCapabilities()
[2019-11-29 11:49:28,367] INFO org.github.dragos.vscode.EnsimeLanguageServer - Initialized with 24616, /home/carlo/Documents/IoT/GPSChat/InteractionManager, ClientCapabilities()
[2019-11-29 11:49:28,369] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - ensime.config = "/home/carlo/Documents/IoT/GPSChat/InteractionManager/.ensime" 
[2019-11-29 11:49:28,369] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - ensime.config = "/home/carlo/Documents/IoT/GPSChat/InteractionManager/.ensime" 
[2019-11-29 11:49:28,893] INFO akka.event.slf4j.Slf4jLogger - Slf4jLogger started
[2019-11-29 11:49:29,053] ERROR org.github.dragos.vscode.EnsimeLanguageServer - initializeEnsime Error: /home/carlo/Documents/IoT/GPSChat/InteractionManager/.ensime
[2019-11-29 11:49:29,053] ERROR org.github.dragos.vscode.EnsimeLanguageServer - initializeEnsime Error: /home/carlo/Documents/IoT/GPSChat/InteractionManager/.ensime
[2019-11-29 11:49:29,115] DEBUG langserver.core.MessageWriter - Content-Length: 146



{"jsonrpc":"2.0","method":"window/showMessage","params":{"tpe":1,"message":"No .ensime file in directory. Run `sbt ensimeConfig` to create one."}}
[2019-11-29 11:49:29,115] DEBUG langserver.core.MessageWriter - Content-Length: 146



{"jsonrpc":"2.0","method":"window/showMessage","params":{"tpe":1,"message":"No .ensime file in directory. Run `sbt ensimeConfig` to create one."}}
[2019-11-29 11:49:29,116] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","method":"window/showMessage","params":{"tpe":1,"message":"No .ensime file in directory. Run `sbt ensimeConfig` to create one."}}
[2019-11-29 11:49:29,116] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","method":"window/showMessage","params":{"tpe":1,"message":"No .ensime file in directory. Run `sbt ensimeConfig` to create one."}}
[2019-11-29 11:49:29,216] DEBUG langserver.core.MessageWriter - Content-Length: 441



{"jsonrpc":"2.0","result":{"capabilities":{"textDocumentSync":1,"hoverProvider":true,"completionProvider":{"resolveProvider":false,"triggerCharacters":["."]},"definitionProvider":true,"referencesProvider":false,"documentHighlightProvider":false,"documentSymbolProvider":true,"workspaceSymbolProvider":false,"codeActionProvider":false,"documentFormattingProvider":false,"documentRangeFormattingProvider":false,"renameProvider":false}},"id":0}
[2019-11-29 11:49:29,216] DEBUG langserver.core.MessageWriter - Content-Length: 441



{"jsonrpc":"2.0","result":{"capabilities":{"textDocumentSync":1,"hoverProvider":true,"completionProvider":{"resolveProvider":false,"triggerCharacters":["."]},"definitionProvider":true,"referencesProvider":false,"documentHighlightProvider":false,"documentSymbolProvider":true,"workspaceSymbolProvider":false,"codeActionProvider":false,"documentFormattingProvider":false,"documentRangeFormattingProvider":false,"renameProvider":false}},"id":0}
[2019-11-29 11:49:29,216] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":{"capabilities":{"textDocumentSync":1,"hoverProvider":true,"completionProvider":{"resolveProvider":false,"triggerCharacters":["."]},"definitionProvider":true,"referencesProvider":false,"documentHighlightProvider":false,"documentSymbolProvider":true,"workspaceSymbolProvider":false,"codeActionProvider":false,"documentFormattingProvider":false,"documentRangeFormattingProvider":false,"renameProvider":false}},"id":0}
[2019-11-29 11:49:29,216] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":{"capabilities":{"textDocumentSync":1,"hoverProvider":true,"completionProvider":{"resolveProvider":false,"triggerCharacters":["."]},"definitionProvider":true,"referencesProvider":false,"documentHighlightProvider":false,"documentSymbolProvider":true,"workspaceSymbolProvider":false,"codeActionProvider":false,"documentFormattingProvider":false,"documentRangeFormattingProvider":false,"renameProvider":false}},"id":0}
[2019-11-29 11:49:29,224] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 52
[2019-11-29 11:49:29,224] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 52
[2019-11-29 11:49:29,225] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"initialized","params":{}}
[2019-11-29 11:49:29,225] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"initialized","params":{}}
[2019-11-29 11:49:29,295] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification Initialized()
[2019-11-29 11:49:29,295] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification Initialized()
[2019-11-29 11:49:48,678] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6595
[2019-11-29 11:49:48,678] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6595
[2019-11-29 11:49:48,688] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","languageId":"scala","version":1,"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}}}
[2019-11-29 11:49:48,688] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didOpen","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","languageId":"scala","version":1,"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}}}
[2019-11-29 11:49:48,694] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:49:48,694] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:49:48,695] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:49:48,695] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":1,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:49:48,699] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":1}
[2019-11-29 11:49:48,699] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":1}
[2019-11-29 11:49:48,699] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":1}
[2019-11-29 11:49:48,699] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":1}
[2019-11-29 11:49:54,042] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6607
[2019-11-29 11:49:54,042] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6607
[2019-11-29 11:49:54,047] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":2},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,047] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":2},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,059] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,059] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,478] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6609
[2019-11-29 11:49:54,478] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6609
[2019-11-29 11:49:54,490] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":3},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,490] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":3},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,500] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,500] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,821] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6610
[2019-11-29 11:49:54,821] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6610
[2019-11-29 11:49:54,836] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":4},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        B\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,836] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":4},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        B\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:54,846] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,846] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:54,850] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 259
[2019-11-29 11:49:54,850] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 259
[2019-11-29 11:49:54,851] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":2,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":9}}}
[2019-11-29 11:49:54,851] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":2,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":9}}}
[2019-11-29 11:49:54,891] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:54,891] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:55,118] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6611
[2019-11-29 11:49:55,118] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6611
[2019-11-29 11:49:55,121] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":5},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Be\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:55,121] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":5},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Be\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:55,125] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:55,125] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:55,517] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6613
[2019-11-29 11:49:55,517] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6613
[2019-11-29 11:49:55,520] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":7},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Beha\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:55,520] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":7},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Beha\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:55,524] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:55,524] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:56,668] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6618
[2019-11-29 11:49:56,668] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6618
[2019-11-29 11:49:56,670] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":11},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behavios\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:56,670] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":11},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behavios\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:56,673] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:56,673] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:57,164] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6619
[2019-11-29 11:49:57,164] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6619
[2019-11-29 11:49:57,165] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":14},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behaviors\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:57,165] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":14},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behaviors\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:57,171] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:57,171] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:57,220] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:57,220] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:57,221] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}
[2019-11-29 11:49:57,221] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":2}}
[2019-11-29 11:49:57,226] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(2)
[2019-11-29 11:49:57,226] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(2)
[2019-11-29 11:49:57,227] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:57,227] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:57,228] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":3,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":17}}}
[2019-11-29 11:49:57,228] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":3,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":17}}}
[2019-11-29 11:49:57,233] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:57,233] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:57,693] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:57,693] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:57,694] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}
[2019-11-29 11:49:57,694] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":3}}
[2019-11-29 11:49:57,698] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(3)
[2019-11-29 11:49:57,698] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(3)
[2019-11-29 11:49:57,698] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6620
[2019-11-29 11:49:57,698] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6620
[2019-11-29 11:49:57,700] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":15},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behaviors.\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:57,700] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":15},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        Behaviors.\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:49:57,704] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:57,704] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:49:57,705] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:57,705] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:57,705] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":4,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":18}}}
[2019-11-29 11:49:57,705] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":4,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":18}}}
[2019-11-29 11:49:57,708] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:57,708] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:58,179] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:58,179] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:49:58,181] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":4}}
[2019-11-29 11:49:58,181] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":4}}
[2019-11-29 11:49:58,187] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(4)
[2019-11-29 11:49:58,187] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(4)
[2019-11-29 11:49:58,187] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:58,187] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:49:58,188] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":5,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":18}}}
[2019-11-29 11:49:58,188] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":5,"method":"textDocument/completion","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":152,"character":18}}}
[2019-11-29 11:49:58,197] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:58,197] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Completions future completed: succes? false
[2019-11-29 11:49:58,929] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:49:58,929] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:49:58,930] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":6,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:49:58,930] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":6,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:49:58,934] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":6}
[2019-11-29 11:49:58,934] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":6}
[2019-11-29 11:49:58,934] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":6}
[2019-11-29 11:49:58,934] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":6}
[2019-11-29 11:50:01,806] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:01,806] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:01,807] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":5}}
[2019-11-29 11:50:01,807] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":5}}
[2019-11-29 11:50:01,809] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(5)
[2019-11-29 11:50:01,809] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(5)
[2019-11-29 11:50:25,000] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6610
[2019-11-29 11:50:25,000] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6610
[2019-11-29 11:50:25,004] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":16},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,004] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":16},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n        \n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,012] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,012] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,266] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6602
[2019-11-29 11:50:25,266] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6602
[2019-11-29 11:50:25,269] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":17},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,269] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":17},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,276] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,276] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,502] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6600
[2019-11-29 11:50:25,502] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6600
[2019-11-29 11:50:25,505] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":18},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,505] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":18},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,513] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,513] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,884] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6598
[2019-11-29 11:50:25,884] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6598
[2019-11-29 11:50:25,886] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,886] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:25,893] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:25,893] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:26,249] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6598
[2019-11-29 11:50:26,249] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 6598
[2019-11-29 11:50:26,251] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:26,251] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didChange","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19},"contentChanges":[{"text":"//#full-example\npackage com.carlop\n\n\nimport akka.actor.typed.ActorRef\nimport akka.actor.typed.ActorSystem\nimport akka.actor.typed.Behavior\nimport akka.actor.typed.scaladsl.Behaviors\n//import com.carlop.GreeterMain.Start\n\n//#greeter-actor\n/*\nobject Greeter {\n  // - Without the ActorRef, the message will not provide information to understand where to\n  //      send back the message.\n  final case class Greet(whom: String, replyTo: ActorRef[Greeted])\n  final case class Greeted(whom: String, from: ActorRef[Greet])\n\n  // Behavior[Greet] means that message will be of type [Greet]\n  // Therefore using Behaviors.receive will create the instance of the behavior immediately.\n  //    while using Behaviors.setup will defer the creation of the instance in a lazy way\n  //    when the actor is started\n  def apply(): Behavior[Greet] = Behaviors.receive { (context, message) =>\n    context.log.info(\"Hello {}!\", message.whom)\n    //#greeter-send-messages\n    message.replyTo ! Greeted(message.whom, context.self)\n    //#greeter-send-messages\n    Behaviors.same\n  }\n}\n//#greeter-actor\n\n//#greeter-bot\nobject GreeterBot {\n\n  def apply(max: Int): Behavior[Greeter.Greeted] = {\n    bot(0, max)\n  }\n\n  private def bot(greetingCounter: Int, max: Int): Behavior[Greeter.Greeted] =\n    Behaviors.receive { (context, message) =>\n      val n = greetingCounter + 1\n      context.log.info(\"Greeting {} for {}\", n, message.whom)\n      if (n == max) {\n        Behaviors.stopped\n      } else {\n        message.from ! Greeter.Greet(message.whom, context.self)\n        bot(n, max)\n      }\n    }\n}\n//#greeter-bot\n\n//#greeter-main\nobject GreeterMain {\n\n  final case class Start(name: String)\n\n  def apply(): Behavior[Start] =\n    Behaviors.setup { context =>\n      //#create-actors\n      val greeter = context.spawn(Greeter(), \"greeter\")\n      print(\"Created the Greeter\")\n      //#create-actors\n\n      Behaviors.receiveMessage { message =>\n        //#create-actors\n        val replyTo = context.spawn(GreeterBot(max = 3), message.name)\n        //#create-actors\n        context.log.info(\"Created the GreeterBot\")\n        greeter ! Greeter.Greet(message.name, replyTo)\n        Behaviors.same\n      }\n    }\n}\n//#greeter-main\n\n//#main-class\nobject AkkaQuickstart extends App {\n  //#actor-system\n  val greeterMain: ActorSystem[GreeterMain.Start] = ActorSystem(GreeterMain(), \"AkkaQuickStart\")\n  //#actor-system\n\n  //#main-send-messages\n  greeterMain ! Start(\"Charles\")\n  //#main-send-messages\n}\n//#main-class\n//#full-example\n*/\nobject Rob {\n  final case class TheWineIsEnded(message: String, to: ActorRef[KingRobert.What], from: ActorRef[KingRobert.What])\n  final case class YourMajesty(message: String, to: ActorRef[Any], from: ActorRef[YourMajesty], father: ActorRef[Any])\n\n  private var _father: ActorRef[Any] = null\n\n  def apply(): Behavior[YourMajesty] = {\n\n    reactToWhat()\n    reactToThenGoAndFillIt()\n    reactToYourMajesty()\n  }\n\n\n  def reactToYourMajesty() : Behavior[YourMajesty] =\n    Behaviors.receive{ (context, message) =>\n\n      if (message.father != null) {\n        _father = message.father\n        message.to ! YourMajesty(\"Vostra maestà\", message.to, context.self, null)\n      }\n      else\n        context.log.info(\"This can't happen\")\n\n      Behaviors.same\n    }\n\n  def reactToWhat(): Behavior[KingRobert.What] =\n    Behaviors.receive{ (context, message) =>\n      message.from ! TheWineIsEnded(\"Non c'è più vino\", message.from, context.self)\n      Behaviors.same\n    }\n\n  def reactToThenGoAndFillIt() : Behavior[KingRobert.ThenGoAndFillIt] =\n    Behaviors.receive { (context, message) =>\n      _father ! MovieDirector.End(\"End the routine\")\n      Behaviors.same\n    }\n}\n\nobject KingRobert {\n  final case class What(message: String, to: ActorRef[Any], from: ActorRef[What])\n  final case class BringMeTheWine(message: String, to: ActorRef[Any], from: ActorRef[BringMeTheWine])\n  final case class ThenGoAndFillIt(message: String, to: ActorRef[Any], from: ActorRef[ThenGoAndFillIt])\n\n  def apply(): Behavior[What] = {\n    reactToYourMajesty()\n    reactToTheWineIsEnded()\n  }\n\n  def reactToTheWineIsEnded() : Behavior[What] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! ThenGoAndFillIt(\"Allora va, e riempilo!\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n\n  def reactToYourMajesty() : Behavior[Rob.YourMajesty] =\n    Behaviors.receive{ (context, message) => {\n        message.from ! What(\"Cosa c'è?\", message.from, context.self)\n        Behaviors.same\n      }\n    }\n}\n\n\nobject MovieDirector {\n\n  final case class Start(name: String)\n  final case class  End (name: String)\n\n  def apply(): Behavior[Start] = {\n    Behaviors.setup( context => {\n        context.log.info(\"The Behavior has been lazily created.\")\n        val refKingRob = context.spawn(KingRobert(), \"KingRobert\")\n        val refRob = context.spawn(Rob(), \"Rob\")\n        reactToEnd()\n        reactToStart(refKingRob, refRob)\n      }\n    )\n  }\n\n  def reactToStart(refKingRob: ActorRef[KingRobert.What], refRob: ActorRef[Rob.YourMajesty]) : Behavior[Start] =\n    Behaviors.receive { (context, message) => {\n        refRob ! Rob.YourMajesty(\"Start\", refKingRob, context.self.asInstanceOf[ActorRef[Any]], context.self.asInstanceOf[ActorRef[Any]])\n        Behaviors.same\n      }\n    }\n\n  def reactToEnd() : Behavior[End] =\n    Behaviors.receive { (context, message) => {\n        context.log.info(\"Stopping all the shack.\")\n        Behaviors.stopped\n      }\n    }\n}\n\n\nobject MainApp extends App {\n  def main(): Unit = {\n    val refMovieDirector = ActorSystem(MovieDirector(), \"MovieDirector\")\n    refMovieDirector ! MovieDirector.Start(\"Go\")\n  }\n}\n\n/*\n* - When defining actors, use case classes to define messages that they can exchange.\n* - Remember that this messages are the public API of an Actor:\n*     this means that they must be understandable and readable.\n* - Then remember that messages are immutable, because they are shared between different threads.\n* - Put each message to its own actor.\n* - Finally is a good practice to put the initial behavior of an actor to its apply method.\n*\n*\n* */"}]}}
[2019-11-29 11:50:26,257] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:26,257] ERROR langserver.core.Connection - failed notification handler
java.lang.NullPointerException: null
	at org.github.dragos.vscode.EnsimeLanguageServer.onChangeTextDocument(EnsimeLanguageServer.scala:167)
	at langserver.core.LanguageServer.$anonfun$new$1(LanguageServer.scala:42)
	at langserver.core.LanguageServer.$anonfun$new$1$adapted(LanguageServer.scala:40)
	at langserver.core.Connection.$anonfun$notifySubscribers$2(Connection.scala:42)
	at scala.runtime.java8.JFunction0$mcV$sp.apply(JFunction0$mcV$sp.java:12)
	at scala.util.Try$.apply(Try.scala:209)
	at langserver.core.Connection.$anonfun$notifySubscribers$1(Connection.scala:42)
	at scala.collection.immutable.List.foreach(List.scala:389)
	at scala.collection.generic.TraversableForwarder.foreach(TraversableForwarder.scala:35)
	at scala.collection.generic.TraversableForwarder.foreach$(TraversableForwarder.scala:35)
	at scala.collection.mutable.ListBuffer.foreach(ListBuffer.scala:44)
	at langserver.core.Connection.notifySubscribers(Connection.scala:41)
	at langserver.core.Connection.$anonfun$start$4(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$4$adapted(Connection.scala:99)
	at play.api.libs.json.JsSuccess.fold(JsResult.scala:15)
	at langserver.core.Connection.$anonfun$start$2(Connection.scala:99)
	at langserver.core.Connection.$anonfun$start$2$adapted(Connection.scala:97)
	at scala.Option.fold(Option.scala:158)
	at langserver.core.Connection.start(Connection.scala:97)
	at langserver.core.LanguageServer.start(LanguageServer.scala:50)
	at org.github.dragos.vscode.EnsimeLanguageServer.start(EnsimeLanguageServer.scala:51)
	at org.github.dragos.vscode.Main$.main(Main.scala:23)
	at org.github.dragos.vscode.Main.main(Main.scala)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.cli.qn.a(Unknown Source)
	at coursier.cli.qm.i(Unknown Source)
	at coursier.cli.qs.a(Unknown Source)
	at c.g.a.c(Unknown Source)
	at a.b.d_(Unknown Source)
	at c.b.d.E.g(Unknown Source)
	at c.b.e.aU.g(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.qm.b(Unknown Source)
	at coursier.cli.M.b(Unknown Source)
	at a.J.d_(Unknown Source)
	at c.E.h(Unknown Source)
	at a.c.a(Unknown Source)
	at coursier.cli.Coursier.main(Unknown Source)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke0(Native Method)
	at java.base/jdk.internal.reflect.NativeMethodAccessorImpl.invoke(NativeMethodAccessorImpl.java:62)
	at java.base/jdk.internal.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:43)
	at java.base/java.lang.reflect.Method.invoke(Method.java:566)
	at coursier.Bootstrap.main(Bootstrap.java:412)
[2019-11-29 11:50:26,258] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 224
[2019-11-29 11:50:26,258] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 224
[2019-11-29 11:50:26,258] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19}}}
[2019-11-29 11:50:26,258] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"textDocument/didSave","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala","version":19}}}
[2019-11-29 11:50:26,262] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - saveTextDocuemnt TextDocumentIdentifier(file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala)
[2019-11-29 11:50:26,262] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - saveTextDocuemnt TextDocumentIdentifier(file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala)
[2019-11-29 11:50:26,338] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:50:26,338] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 225
[2019-11-29 11:50:26,339] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":7,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:50:26,339] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":7,"method":"textDocument/documentSymbol","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"}}}
[2019-11-29 11:50:26,342] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":7}
[2019-11-29 11:50:26,342] DEBUG langserver.core.MessageWriter - Content-Length: 36



{"jsonrpc":"2.0","result":[],"id":7}
[2019-11-29 11:50:26,343] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":7}
[2019-11-29 11:50:26,343] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","result":[],"id":7}
[2019-11-29 11:50:28,872] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:50:28,872] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 260
[2019-11-29 11:50:28,873] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":8,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":162,"character":33}}}
[2019-11-29 11:50:28,873] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":8,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":162,"character":33}}}
[2019-11-29 11:50:28,876] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got goto definition request at (162, 33).
[2019-11-29 11:50:28,876] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got goto definition request at (162, 33).
[2019-11-29 11:50:28,880] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Goto Definition future completed: succes? false
[2019-11-29 11:50:28,880] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Goto Definition future completed: succes? false
[2019-11-29 11:50:29,875] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 255
[2019-11-29 11:50:29,875] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 255
[2019-11-29 11:50:29,877] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":22}}}
[2019-11-29 11:50:29,877] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":9,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":22}}}
[2019-11-29 11:50:29,882] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (161, 22).
[2019-11-29 11:50:29,882] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (161, 22).
[2019-11-29 11:50:29,885] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:29,885] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:29,886] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:29,886] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:29,899] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:29,899] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:29,900] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":8}}
[2019-11-29 11:50:29,900] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":8}}
[2019-11-29 11:50:29,901] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(8)
[2019-11-29 11:50:29,901] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(8)
[2019-11-29 11:50:29,902] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:29,902] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 62
[2019-11-29 11:50:29,904] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":9}}
[2019-11-29 11:50:29,904] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":9}}
[2019-11-29 11:50:29,916] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(9)
[2019-11-29 11:50:29,916] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(9)
[2019-11-29 11:50:31,086] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:31,086] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:31,087] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":20}}}
[2019-11-29 11:50:31,087] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":10,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":20}}}
[2019-11-29 11:50:31,090] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (161, 20).
[2019-11-29 11:50:31,090] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (161, 20).
[2019-11-29 11:50:31,093] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:31,093] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:31,093] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:31,093] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:31,222] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:31,222] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:31,223] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":10}}
[2019-11-29 11:50:31,223] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":10}}
[2019-11-29 11:50:31,224] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(10)
[2019-11-29 11:50:31,224] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(10)
[2019-11-29 11:50:31,971] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 261
[2019-11-29 11:50:31,971] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 261
[2019-11-29 11:50:31,973] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":11,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":23}}}
[2019-11-29 11:50:31,973] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":11,"method":"textDocument/definition","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":161,"character":23}}}
[2019-11-29 11:50:31,976] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got goto definition request at (161, 23).
[2019-11-29 11:50:31,976] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got goto definition request at (161, 23).
[2019-11-29 11:50:31,980] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Goto Definition future completed: succes? false
[2019-11-29 11:50:31,980] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - Goto Definition future completed: succes? false
[2019-11-29 11:50:32,127] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:32,127] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:32,128] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":12,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":162,"character":23}}}
[2019-11-29 11:50:32,128] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":12,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":162,"character":23}}}
[2019-11-29 11:50:32,131] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (162, 23).
[2019-11-29 11:50:32,131] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (162, 23).
[2019-11-29 11:50:32,132] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:32,132] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:32,132] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:32,132] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:35,919] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:35,919] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:35,920] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":12}}
[2019-11-29 11:50:35,920] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":12}}
[2019-11-29 11:50:35,922] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(12)
[2019-11-29 11:50:35,922] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(12)
[2019-11-29 11:50:55,472] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:55,472] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 256
[2019-11-29 11:50:55,473] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":150,"character":22}}}
[2019-11-29 11:50:55,473] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":13,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":150,"character":22}}}
[2019-11-29 11:50:55,480] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (150, 22).
[2019-11-29 11:50:55,480] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (150, 22).
[2019-11-29 11:50:55,483] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:55,483] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:50:55,483] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:55,483] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:50:55,553] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:55,553] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:55,554] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":11}}
[2019-11-29 11:50:55,554] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":11}}
[2019-11-29 11:50:55,555] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(11)
[2019-11-29 11:50:55,555] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(11)
[2019-11-29 11:50:55,555] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:55,555] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:50:55,555] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":13}}
[2019-11-29 11:50:55,555] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":13}}
[2019-11-29 11:50:55,556] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(13)
[2019-11-29 11:50:55,556] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(13)
[2019-11-29 11:51:07,912] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 253
[2019-11-29 11:51:07,912] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 253
[2019-11-29 11:51:07,914] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":6,"character":0}}}
[2019-11-29 11:51:07,914] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":14,"method":"textDocument/hover","params":{"textDocument":{"uri":"file:///home/carlo/Documents/IoT/GPSChat/InteractionManager/interactionmanager/src/main/scala/com/carlop/AkkaQuickstart.scala"},"position":{"line":6,"character":0}}}
[2019-11-29 11:51:07,919] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (6, 0).
[2019-11-29 11:51:07,919] INFO org.github.dragos.vscode.EnsimeLanguageServer - Got hover request at (6, 0).
[2019-11-29 11:51:07,920] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:51:07,920] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:51:07,920] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - DocUriAtPointReq future completed: succes? false
[2019-11-29 11:51:07,920] DEBUG org.github.dragos.vscode.EnsimeLanguageServer - TypeAtPointReq future completed: succes? false
[2019-11-29 11:51:14,052] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:51:14,052] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 63
[2019-11-29 11:51:14,053] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":14}}
[2019-11-29 11:51:14,053] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","method":"$/cancelRequest","params":{"id":14}}
[2019-11-29 11:51:14,057] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(14)
[2019-11-29 11:51:14,057] ERROR org.github.dragos.vscode.EnsimeLanguageServer - Unknown notification CancelRequest(14)
[2019-11-29 11:51:14,127] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 59
[2019-11-29 11:51:14,127] DEBUG langserver.core.MessageReader - Received headers:
Content-Length: 59
[2019-11-29 11:51:14,132] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":15,"method":"shutdown","params":null}
[2019-11-29 11:51:14,132] DEBUG langserver.core.Connection - Received {"jsonrpc":"2.0","id":15,"method":"shutdown","params":null}
[2019-11-29 11:51:14,243] DEBUG langserver.core.MessageWriter - Content-Length: 199



{"jsonrpc":"2.0","error":{"code":-32602,"message":"Invalid params","data":{"meaning":"Invalid method parameter(s).","error":{"obj":[{"msg":["command parameters must be given"],"args":[]}]}}},"id":15}
[2019-11-29 11:51:14,243] DEBUG langserver.core.MessageWriter - Content-Length: 199



{"jsonrpc":"2.0","error":{"code":-32602,"message":"Invalid params","data":{"meaning":"Invalid method parameter(s).","error":{"obj":[{"msg":["command parameters must be given"],"args":[]}]}}},"id":15}
[2019-11-29 11:51:14,243] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","error":{"code":-32602,"message":"Invalid params","data":{"meaning":"Invalid method parameter(s).","error":{"obj":[{"msg":["command parameters must be given"],"args":[]}]}}},"id":15}
[2019-11-29 11:51:14,243] DEBUG langserver.core.MessageWriter - payload: {"jsonrpc":"2.0","error":{"code":-32602,"message":"Invalid params","data":{"meaning":"Invalid method parameter(s).","error":{"obj":[{"msg":["command parameters must be given"],"args":[]}]}}},"id":15}
[2019-11-29 11:51:15,136] INFO langserver.core.MessageReader - End of stream, terminating thread
[2019-11-29 11:51:15,136] INFO langserver.core.MessageReader - End of stream, terminating thread
[2019-11-29 11:51:15,136] INFO org.github.dragos.vscode.EnsimeLanguageServer - Shutdown request
[2019-11-29 11:51:15,136] INFO org.github.dragos.vscode.EnsimeLanguageServer - Shutdown request
[2019-11-29 11:51:15,137] INFO org.github.dragos.vscode.EnsimeLanguageServer - Shutting down actor system.
[2019-11-29 11:51:15,137] INFO org.github.dragos.vscode.EnsimeLanguageServer - Shutting down actor system.
[2019-11-29 11:51:15,178] INFO org.github.dragos.vscode.EnsimeLanguageServer - Actor system down.
[2019-11-29 11:51:15,178] INFO org.github.dragos.vscode.EnsimeLanguageServer - Actor system down.
